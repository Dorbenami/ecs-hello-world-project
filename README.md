# ğŸš€ Hello World on AWS Fargate - Fullstack Project (Terraform + GitHub Actions)

This project showcases an end-to-end deployment of a simple "Hello World" web app to AWS using ECS Fargate. It includes:

* **Infrastructure provisioning** via Terraform
* **Dockerized application** hosted on Amazon ECR
* **CI/CD automation** with GitHub Actions that rebuilds and deploys on every push to `main`

---

## ğŸ“¦ Project Structure

```bash
ecs-hello-world-monorepo/
â”‚
â”œâ”€â”€ infra/                          # Terraform configuration
â”‚   â”œâ”€â”€ main.tf
â”‚   â”œâ”€â”€ variables.tf
â”‚   â”œâ”€â”€ outputs.tf
â”‚   â””â”€â”€ modules/                    # VPC, ECS, etc.
â”‚
â”œâ”€â”€ hello-world-app/               # Application code and CI/CD
â”‚   â”œâ”€â”€ index.html
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â””â”€â”€ .github/
â”‚       â””â”€â”€ workflows/
â”‚           â””â”€â”€ main.yml           # GitHub Actions workflow
â”‚
â””â”€â”€ README.md                      # You're here ğŸš€
```

> ğŸ’¡ **Note**: In production, this monorepo would typically be split into two separate GitHub repositories:
>
> * `ecs-hello-world-infra` for Terraform code
> * `ecs-hello-world-app` for the app code and CI/CD workflow

---

## ğŸ¯ What This Project Does

* Builds a custom VPC with public/private subnets
* Creates an Application Load Balancer (ALB)
* Provisions an ECS Cluster and Service on Fargate
* Deploys a Dockerized app from ECR to ECS
* Automates image builds and deployments using GitHub Actions

---

## ğŸ”§ Prerequisites

* AWS Account
* AWS CLI installed and configured
* Docker installed locally
* Terraform installed
* GitHub account

---

## ğŸ§± Infrastructure Setup (Terraform)

```bash
cd infra/
terraform init
terraform apply
```

This will:

* Create a VPC, Subnets, IGW, NAT GW, Route Tables
* Set up ECS Cluster, ALB, IAM Roles, Security Groups
* Create an Amazon ECR Repository

### Outputs

Terraform will output:

* `alb_url`: Use this to access your deployed app

---

## ğŸ³ Push First Image Manually (one-time)

```bash
cd hello-world-app/
aws ecr get-login-password --region us-east-1 | \
  docker login --username AWS --password-stdin <aws_account_id>.dkr.ecr.us-east-1.amazonaws.com

docker build -t hello-world .
docker tag hello-world:latest <your-ecr-url>:latest
docker push <your-ecr-url>:latest
```

---

## ğŸ” GitHub Actions CI/CD

### What It Does:

On every push to `main` in the `hello-world-app` folder:

* Builds Docker image
* Pushes to ECR
* Registers a new ECS Task Definition
* Updates the ECS Service to use it

### Required GitHub Secrets:

In your GitHub repo:

```
AWS_ACCESS_KEY_ID
AWS_SECRET_ACCESS_KEY
AWS_REGION (us-east-1)
ECR_REPOSITORY (<your-account-id>.dkr.ecr.<region>.amazonaws.com/hello-world)
ECS_CLUSTER_NAME (hello-world-cluster)
ECS_SERVICE_NAME (hello-world-service)
```

### Triggering a Deployment:

```bash
cd hello-world-app/
echo "<!-- updated -->" >> index.html
git add index.html
git commit -m "feat: update hello world text"
git push origin main
```

Check GitHub Actions â†’ Your workflow should run and deploy the new image.

---

## ğŸ“„ ECS Task Definition - Whatâ€™s Inside?

The task definition is generated by GitHub Actions and includes:

* Your container image (from ECR)
* CPU/memory settings
* Port mappings (usually port 80)
* Execution role ARN like:
  `arn:aws:iam::<account-id>:role/ecsTaskExecutionRole`

## ğŸ§¹ Teardown

To destroy everything:

```bash
cd infra/
terraform destroy
```

To redeploy:

1. `terraform apply`
2. Rebuild + Push image manually once (only first time)
3. After that, let GitHub Actions handle it

---

## âœ… Summary

| Feature                  | Supported âœ… |
| ------------------------ | ----------- |
| ECS Fargate              | âœ…           |
| ALB with Target Group    | âœ…           |
| Private/Public Subnets   | âœ…           |
| Docker + ECR Integration | âœ…           |
| GitHub Actions CI/CD     | âœ…           |
| Modular Terraform        | âœ…           |

---

Enjoy deploying with Terraform & GitHub Actions! ğŸ‰
